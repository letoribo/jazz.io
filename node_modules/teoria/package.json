{
  "name": "teoria",
  "version": "0.5.0",
  "description": "Music theory for JavaScript",
  "homepage": "http://saebekassebil.github.com/teoria",
  "keywords": [
    "music",
    "theory",
    "jazz",
    "classical",
    "chord"
  ],
  "main": "./dist/teoria.js",
  "author": {
    "name": "Jakob Miland",
    "email": "saebekassebil",
    "url": "https://github.com/saebekassebil"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/saebekassebil/teoria"
  },
  "license": {
    "type": "MIT",
    "url": "https://raw.github.com/saebekassebil/teoria/master/LICENSE"
  },
  "scripts": {
    "test": "jake test",
    "lint": "jake lint",
    "prepublish": "jake build"
  },
  "devDependencies": {
    "colors": ">=0.6.0",
    "mingler": ">=0.1.4",
    "jshint": ">=0.9.0",
    "uglify-js": ">=2.0.0",
    "vows": ">= 0.6.0",
    "jake": "~0.5.0"
  },
  "readme": "Teoria.js\n=========\n\nTeoria.js is a lightweight and fast JavaScript library\nfor music theory, both Jazz and Classical. It aims at providing an intuitive\nprogramming interface for music software (such as Sheet Readers,\nSheet Writers, MIDI Players etc.).\n\nFeatures\n---------\n\n - A note object (`teoria.note`), which understands alterations, octaves,\n key number, frequency and etc. and Helmholtz notation\n\n - A chord object (`teoria.chord`), which understands everything\n from simple major/minor chords to advanced Jazz chords (Ab#5b9, F(#11) and such)\n\n - A scale object (`teoria.scale`), The scale object is a powerful presentation of\n a scale, which supports quite a few handy methods. A scale can either be\n constructed from the predefined scales, which by default contains the 7 modes\n (Ionian, Dorian, Phrygian etc.) a major and minor pentatonic and the harmonic\n chromatic scale or from an arbitrary array of intervals. The scale object\n also supports solfège, which makes it perfect for tutorials on sight-reading.\n\n - An interval object (`teoria.interval`), which makes it easy to find the\n interval between two notes, or find a note that is a given interval from a note.\n There's also support for counting the interval span in semitones and inverting the\n interval.\n\nBuilding\n--------\n\nBuilding the library is simple. Just fetch the code:\n\n```bash\ngit clone git://github.com/saebekassebil/teoria\n```\n\nInstall Jake (the build tool)\n\n```bash\nnpm install -g jake\n```\n\nEnter the directory, and install the dependencies:\n```bash\ncd teoria && npm install\n```\n\nAnd build the library! You can build a minified version, by adding `[minify]` to the command:\n```bash\njake build\n# or\njake build[minify]\n```\n\nIf you want to include some of the more fancy scales, that ship with the repository\nbut doesn't automatically gets added to the build, you can configure which scales\nto include in the build like this:\n```bash\njake build scales=+blues,+flamenco,-chromatic\n```\n\nAs you can see, `scales` is just a comma-separated list of scale names, prefixed\nwith either a `+` or a `-` to signify whether they should be included or not.\n\nTake a look in the `src/scales` directory, if you want to know which scales there is,\nand feel free to submit pull requests for other ones!\n\nSyntax\n---------\n\nThis is just a short introduction to what teoria-code looks like,\nfor a technical library reference, look further down this document.\n\n```javascript\n\n// Create notes:\nvar a4 = teoria.note('a4');       // Scientific notation\nvar g5 = teoria.note(\"g''\");      // Helmholtz notation\nvar c3 = teoria.note.fromKey(28); // From a piano key number\n\n// Find and create notes based on intervals\nteoria.interval(a4, g5);    // Returns a TeoriaInterval object representing a minor seventh\nteoria.interval(a4, 'M6');  // Returns a TeoriaNote representing F#5\na4.interval('m3');          // Returns a TeoriaNote representing C#4\na4.interval(g5);            // Returns a TeoriaInterval object representing a minor seventh\na4.interval(teoria.note('bb5')).invert(); // Returns a TeoriaInterval representing a major seventh\n\n// Create scales, based on notes.\na4.scale('mixolydian').simple();  // Returns: [\"a\", \"b\", \"c#\", \"d\", \"e\", \"f#\", \"g\"]\na4.scale('aeolian').simple();     // Returns: [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\ng5.scale('ionian').simple();      // Returns: [\"g\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f#\"]\ng5.scale('dorian');               // Returns a TeoriaScale object\n\n// Create chords with the powerful chord parser\na4.chord('sus2').name;    // Returns the name of the chord: 'Asus2'\nc3.chord('m').name;       // Returns 'Cm'\nteoria.chord('Ab#5b9');   // Returns a TeoriaChord object, representing a Ab#5b9 chord\ng5.chord('dim');          // Returns a TeoriaChord object, representing a Gdim chord\n\n// Calculate note frequencies or find the note corresponding to a frequency\nteoria.note.fromFrequency(467); // Returns: {'note':{...},'cents':3.102831} -> A4# a little out of tune.\na4.fq(); // Outputs 440\ng5.fq(); // Outputs 783.9908719634985\n\n// teoria allows for crazy chaining:\nteoria.note('a')    // Create a note, A3\n  .scale('lydian')  // Create a lydian scale with that note as root (A lydian)\n  .interval('M2')   // Transpose the whole scale a major second up (B lydian)\n  .get('third')     // Get the third note of the scale (D#4)\n  .chord('maj9')    // Create a maj9 chord with that note as root (D#maj9)\n  .toString();      // Make a string representation: 'D#maj9'\n```\n\nDocumentation\n------------------------\n\n## teoria.note (name | coord[, duration])\n\n*name* - The name argument is the note name as a string. The note can both\nbe expressed in scientific and Helmholtz notation.\nSome examples of valid note names: `Eb4`, `C#,,`, `C4`, `d#''`, `Ab2`\n\n*coord* - If the first argument isn't a string, but a coord array,\nit will instantiate a `TeoriaNote` instance.\n\n*duration* - The duration argument is an optional `object` argument.\nThe object has two also optional parameters:\n\n - `value` - A `number` corresponding to the value of the duration, such that:\n`1 = whole`, `2 = half (minim)`, `4 = quarter`, `8 = eight`\n\n - `dots` - The number of dots attached to the note. Defaults to `0`.\n\n### teoria.note.fromKey(key)\nA static method that returns an instance of TeoriaNote set to the note\nat the given piano key, where A0 is key number 1.\nSee [Wikipedia's piano key article](http://en.wikipedia.org/wiki/Piano_key_frequencies)\nfor more information.\n\n### teoria.note.fromFrequency(fq)\nA static method returns an object containing two elements:\n\n*note* - A `TeoriaNote` which corresponds to the closest note with the given frequency\n\n*cents* - A number value of how many cents the note is out of tune\n\n### teoria.note.fromMIDI(note)\n - Returns an instance of TeoriaNote set to the corresponding MIDI note value.\n\n*note* - A number ranging from 0-127 representing a MIDI note value\n\n### teoria.note.fromString(note)\n - Returns an instance of TeoriaNote representing the note name\n\n*note* - The name argument is the note name as a string. The note can both\nbe expressed in scientific and Helmholtz notation.\nSome examples of valid note names: `Eb4`, `C#,,`, `C4`, `d#''`, `Ab2`\n\n#### TeoriaNote.name()\n - The name of the note, in lowercase letter (*only* the name, not the\n accidental signs)\n\n#### TeoriaNote.octave()\n - The numeric value of the octave of the note\n\n#### TeoriaNote.duration\n - The duration object as described in the constructor for TeoriaNote\n\n#### TeoriaNote.accidental()\n - Returns the string symbolic of the accidental sign (`x`, `#`, `b` or `bb`)\n\n#### TeoriaNote.accidentalValue()\n - Returns the numeric value (mostly used internally) of the sign:\n`x = 2, # = 1, b = -1, bb = -2`\n\n#### TeoriaNote#key([whitenotes])\n - Returns the piano key number. E.g. A4 would return 49\n\n*whitenotes* - If this parameter is set to `true` only the white keys will\nbe counted when finding the key number. This is mostly for internal use.\n\n#### TeoriaNote#fq([concertPitch])\n - Calculates and returns the frequency of the note.\n\n*concertPitch* - If supplied this number will be used instead of the normal\nconcert pitch which is 440hz. This is useful for some classical music.\n\n#### TeoriaNote#chroma()\n - Returns the pitch class (index) of the note.\n\nThis allows for easy enharmonic checking:\n\n    teoria.note('e').chroma() === teoria.note('fb').chroma();\n\nThe chroma number is ranging from pitch class C which is 0 to 11 which is B\n\n#### TeoriaNote#scale(scaleName)\n - Returns an instance of TeoriaScale, with the tonic/root set to this note.\n\n*scaleName* - The name of the scale to be returned. `'minor'`,\n`'chromatic'`, `'ionian'` and others are valid scale names.\n\n#### TeoriaNote#interval(interval)\n - A sugar function for calling teoria.interval(note, interval);\n\nLook at the documentation for `teoria.interval`\n\n#### TeoriaNote#transpose(interval)\n - Like the `#interval` method, but changes `this` note, instead of returning a new\n\n#### TeoriaNote#chord([name])\n - Returns an instance of TeoriaChord, with root note set to this note\n\n*name* - The name attribute is the last part of the chord symbol.\nExamples: `'m7'`, `'#5b9'`, `'major'`. If the name parameter\nisn't set, a standard major chord will be returned.\n\n#### TeoriaNote#helmholtz()\n - Returns the note name formatted in Helmholtz notation.\n\nExample: `teoria.note('A5').helmholtz() -> \"a''\"`\n\n#### TeoriaNote#scientific()\n - Returns the note name formatted in scientific notation.\n\nExample: `teoria.note(\"ab'\").scientific() -> \"Ab4\"`\n\n#### TeoriaNote#enharmonics(oneAccidental)\n - Returns all notes that are enharmonic with the note\n\n*oneAccidental* - Boolean, if set to true, only enharmonic notes with one\naccidental is returned. E.g. results such as 'eb' and 'c#' but not 'ebb' and 'cx'\n\n```javascript\nteoria.note('c').enharmonics().toString();\n// -> 'dbb, b#'\n\nteoria.note('c').enharmonics(true).toString();\n// -> 'b#'\n```\n\n#### TeoriaNote#durationInSeconds(bpm, beatUnit)\n - Returns the duration of the note, given a tempo (in bpm) and a beat unit\n (the lower numeral of the time signature)\n\n#### TeoriaNote#solfege(scale, showOctaves)\n - Returns the solfege step in the given scale context\n\n*scale* - An instance of `TeoriaScale`, which is the context of the solfege step measuring\n\n*showOctaves* - A boolean. If set to true, a \"Helmholtz-like\" notation will be\nused if there's bigger intervals than an octave\n\n#### TeoriaNote#durationName()\n - Returns the duration name.\n\nExamples: `teoria.note('A', 8).durationName() -> 'eighth'`,\n`teoria.note('C', 16).durationName() -> 'sixteenth'`\n\n#### TeoriaNote#scaleDegree(scale)\n - Returns this note's degree in a given scale (TeoriaScale). For example a\n `D` in a C major scale will return `2` as it is the second degree of that scale.\n If however the note *isn't* a part of the scale, the degree returned will be\n `0`, meaning that the degree doesn't exist. This allows this method to be both\n a scale degree index finder *and* an \"isNoteInScale\" method.\n\n*scale* - An instance of `TeoriaScale` which is the context of the degree measuring\n\n#### TeoriaNote#toString([dontShow])\n - Usability function for returning the note as a string\n\n*dontShow* - If set to `true` the octave will not be included in the returned string.\n\n\n## TeoriaChord(root, chord)\n - A chord class with a lot of functionality to alter and analyze the chord.\n\n*root* - A `TeoriaNote` instance which is to be the root of the chord\n\n*chord* - A string containing the chord symbol. This can be anything from\nsimple chords, to super-advanced jazz chords thanks to the detailed and\nrobust chord parser engine. Example values:\n`'m'`, `'m7'`, `'#5b9'`, `'9sus4` and `'#11b5#9'`\n\n### teoria.chord(name || note[, octave || symbol])\n - A simple function for getting the notes, no matter the octave, in a chord\n\n*name* - A string containing the full chord symbol, with note name. Examples:\n`'Ab7'`, `'F#(#11b5)'`\n\n*note* - Instead of supplying a string containing the full chord symbol,\none can pass a `TeoriaNote` object instead. The note will be considered root in\nthe new chord object\n\n*octave* - If the first argument of the function is a chord name (`typeof \"string\"`),\nthen the second argument is an optional octave number (`typeof \"number\"`) of the root.\n\n*symbol* - A string containing the chord symbol (excluding the note name)\n\n#### TeoriaChord.name\n - Holds the full chord symbol, inclusive the root name.\n\n#### TeoriaChord.root\n - Holds the `TeoriaNote` that is the root of the chord.\n\n#### TeoriaChord#notes()\n - Returns an array of `TeoriaNote`s that the chord consists of.\n\n#### TeoriaChord#voicing([voicing])\n - Works both as a setter and getter. If no parameter is supplied the\n current voicing is returned as an array of `TeoriaInterval`s\n\n*voicing* - An optional array of intervals in simple-format\nthat represents the current voicing of the chord.\n\nHere's an example:\n```javascript\nvar bbmaj = teoria.chord('Bbmaj7');\n// Default voicing:\nbbmaj.voicing();  // #-> ['P1', 'M3', 'P5', 'M7'];\nbbmaj.notes();    // #-> ['bb', 'd', 'f', 'a'];\n\n// New voicing\nbbmaj.voicing(['P1', 'P5', 'M7', 'M10']);\nbbmaj.notes();    // #-> ['bb', 'f', 'a', 'd'];\n```\n*NB:* Note that above returned results are pseudo-results, as they will be\nreturned wrapped in `TeoriaInterval` and `TeoriaNote` objects.\n\n#### TeoriaChord#quality()\n - Returns a string which holds the quality of the chord, `'major'`, `'minor'`,\n `'augmented'`, `'diminished'`, `'half-diminished'`, `'dominant'` or `undefined`\n\n#### TeoriaChord#get(interval)\n - Returns the note at a given interval in the chord, if it exists.\n\n*interval* - A string name of an interval, for example `'third'`, `'fifth'`, `'ninth'`.\n\n#### TeoriaChord#dominant([additional])\n - Returns the naïvely chosen dominant which is a perfect fifth away.\n\n*additional* - Additional chord extension, for example: `'b9'` or `'#5'`\n\n#### TeoriaChord#subdominant([additional])\n - Returns the naïvely chosen subdominant which is a perfect fourth away.\n\n*additional* - Like the dominant's.\n\n#### TeoriaChord#parallel([additional])\n - Returns the parallel chord for major and minor triads\n\n*additional* - Like the dominant's\n\n#### TeoriaChord#chordType()\n - Returns the type of the chord: `'dyad'`, `'triad'`, `'trichord'`,\n `'tetrad'` or `'unknown'`.\n\n#### TeoriaChord#interval(interval)\n - Returns the same chord, a `interval` away\n\n#### TeoriaChord#transpose(interval)\n - Like the `#interval` method, except it's `this` chord that gets changed instead of\n returning a new chord.\n\n#### TeoriaChord#toString()\n - Simple usability function which is an alias for TeoriaChord.name\n\n\n## TeoriaScale(tonic, scale)\n - The teoria representation of a scale, with a given tonic.\n\n*tonic* - A `TeoriaNote` which is to be the tonic of the scale\n\n*scale* - Can either be a name of a scale (string), or an array of\nabsolute intervals that defines the scale. The scales supported by default are:\n\n - major\n - minor\n - ionian (Alias for major)\n - dorian\n - phrygian\n - lydian\n - mixolydian\n - aeolian (Alias for minor)\n - locrian\n - majorpentatonic\n - minorpentatonic\n - chromatic\n - harmonicchromatic (Alias for chromatic)\n\n### teoria.scale(tonic, scale)\n - Sugar function for constructing a new `TeoriaScale` object\n\n### TeoriaScale.notes()\n - Returns an array of `TeoriaNote`s which is the scale's notes\n\n### TeoriaScale.name\n - The name of the scale (if available). Type `string` or `undefined`\n\n### TeoriaScale.tonic\n - The `TeoriaNote` which is the scale's tonic\n\n### TeoriaScale#simple()\n - Returns an `Array` of only the notes' names, not the full `TeoriaNote` objects.\n\n### TeoriaScale#type()\n - Returns the type of the scale, depending on the number of notes.\n A scale of length x gives y:\n  - 2 gives 'ditonic'\n  - 3 gives 'tritonic'\n  - 4 gives 'tetratonic'\n  - 5 gives 'pentatonic'\n  - 6 gives 'hexatonic',\n  - 7 gives 'heptatonic',\n  - 8 gives 'octatonic'\n\n### TeoriaScale#get(index)\n - Returns the note at the given scale index\n\n*index* - Can be a number referring to the scale step, or the name (string) of the\nscale step. E.g. 'first', 'second', 'fourth', 'seventh'.\n\n### TeoriaScale#solfege(index, showOctaves)\n - Returns the solfege name of the given scale step\n\n*index* Same as `TeoriaScale#get`\n\n*showOctaves* - A boolean meaning the same as `showOctaves` in `TeoriaNote#solfege`\n\n\n## teoria.interval(from, to)\n - A sugar function for the `#from` and `#between` methods of the same namespace and\n for creating `TeoriaInterval` objects.\n\n#### teoria.interval(`string`: from)\n - A sugar method for the `teoria.interval.toCoord` function\n\n#### teoria.interval(`TeoriaNote`: from, `string`: to)\n - A sugar method for the `teoria.interval.from` function\n\n#### teoria.interval(`TeoriaNote`: from, `TeoriaNote`: to)\n - A sugar method for the `teoria.interval.between` function\n\n#### teoria.interval.from(from, to)\n - Returns a note which is a given interval away from a root note.\n\n*from* - The `TeoriaNote` which is the root of the measuring\n\n*to* - A `TeoriaInterval`\n\n#### teoria.interval.between(from, to)\n - Returns an interval object which represents the interval between two notes.\n\n*from* and *to* are two `TeoriaNote`s which are the notes that the\ninterval is measured from. For example if 'a' and 'c' are given, the resulting\ninterval object would represent a minor third.\n\n```javascript\nteoria.interval.between(teoria.note(\"a\"), teoria.note(\"c'\")) -> teoria.interval('m3')\n```\n\n#### teoria.interval.toCoord(simpleInterval)\n - Returns a `TeoriaInterval` representing the interval expressed in string form.\n\n#### teoria.interval.invert(simpleInterval)\n - Returns the inversion of the interval provided\n\n*simpleInterval* - An interval represented in simple string form. Examples:\n\n - 'm3' = minor third\n - 'P4' = perfect fourth\n - 'A4' = augmented fifth\n - 'd7' = diminished seventh\n - 'M6' = major sixth.\n\n`'m' = minor`, `'M' = major`, `'A' = augmented` and\n`'d' = diminished`\n\nThe number may be prefixed with a `-` to signify that its direction is down. E.g.:\n\n`m-3` means a descending minor third, and `P-5` means a descending perfect fifth.\n\n## TeoriaInterval(coord)\n - A representation of a music interval\n\n#### TeoriaInterval.coord\n - The interval representation of the interval\n\n#### TeoriaInterval.number()\n - The interval number (A ninth = 9, A seventh = 7, fifteenth = 15)\n\n#### TeoriaInterval.value()\n - The value of the interval - That is a ninth = 9, but a downwards ninth is = -9\n\n#### TeoriaInterval.toString()\n - Returns the *simpleInterval* representation of the interval. E.g. `'P5'`,\n `'M3'`, `'A9'`, etc.\n\n#### TeoriaInterval.base()\n - Returns the name of the simple interval (not compound)\n\n#### TeoriaInterval.type()\n - Returns the type of array, either `'perfect'` (1, 4, 5, 8) or `'minor'` (2, 3, 6, 7)\n\n#### TeoriaInterval.quality([verbose])\n - The quality of the interval (`'dd'`, `'d'` `'m'`, `'P'`, `'M'`, `'A'` or `'AA'`)\n\n*verbose*  is set to a truish value, then long quality names are returned:\n `'doubly diminished'`, `'diminished'`, `'minor'`, etc.\n\n#### TeoriaInterval.direction([dir])\n - The direction of the interval\n\n*dir* - If supplied, then the interval's direction is to the `newDirection`\nwhich is either `'up'` or `'down'`\n\n#### TeoriaInterval#semitones()\n - Returns the `number` of semitones the interval span.\n\n#### TeoriaInterval#simple([ignoreDirection])\n - Returns the simple part of the interval as a TeoriaInterval. Example:\n\n*ignoreDirection* - An optional boolean that, if set to `true`, returns the\n\"direction-agnostic\" interval. That is the interval with a positive number.\n\n```javascript\nteoria.interval('M17').simple();    // #-> 'M3'\nteoria.interval('m23').simple();    // #-> 'm2'\nteoria.interval('P5').simple();     // #-> 'P5'\nteoria.interval('P-4').simple();    // #-> 'P-4'\n\n// With ignoreDirection = true\nteoria.interval('M3').simple(true);     // #->'M3'\nteoria.interval('m-10').simple(true);   // #-> 'm3'\n```\n\n*NB:* Note that above returned results are pseudo-results, as they will be\nreturned wrapped in `TeoriaInterval` objects.\n\n#### TeoriaInterval#octaves()\n - Returns the number of compound intervals\n\n#### TeoriaInterval#isCompound()\n - Returns a boolean value, showing if the interval is a compound interval\n\n#### TeoriaInterval#add(interval)\n - Adds the `interval` to this interval, and returns a `TeoriaInterval`\n representing the result of the addition\n\n#### TeoriaInterval#equal(interval)\n - Returns true if the supplied `interval` is equal to this interval\n\n#### TeoriaInterval#greater(interval)\n - Returns true if the supplied `interval` is greater than this interval\n\n#### TeoriaInterval#smaller(interval)\n - Returns true if the supplied `interval` is smaller than this interval\n\n#### TeoriaInterval#invert()\n - Returns the inverted interval as a `TeoriaInterval`\n\n#### TeoriaInterval#qualityValue() - *internal*\n - Returns the relative to default, value of the quality.\n E.g. a teoria.interval('M6'), will have a relative quality value of 1, as all the\n intervals defaults to minor and perfect respectively.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/saebekassebil/teoria/issues"
  },
  "_id": "teoria@0.5.0",
  "dist": {
    "shasum": "96c9ebdff934fdef9b5b038f93d626ae7a032458"
  },
  "_from": "teoria@",
  "_resolved": "https://registry.npmjs.org/teoria/-/teoria-0.5.0.tgz"
}
